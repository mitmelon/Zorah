//Radar Object
var radar = new ManomiteRadar;
var storage = radar._Storage();
var Timer = radar._Watch();
var quenee = [];
var timee = 0;
var ajax_requester;

let url = new URL(window.location.href);

//Animate Css
const animateCSS = (element, animation, seconds = null, prefix = 'animate__',) =>
  new Promise((resolve, reject) => {
    const animationName = `${prefix}${animation}`;
    const node = document.querySelector(element);

    node.classList.add(`${prefix}animated`, animationName);

    if (seconds !== null) {
      node.style.setProperty(`--animation-duration`, seconds + 's');
    }

    function handleAnimationEnd(event) {
      event.stopPropagation();
      node.classList.remove(`${prefix}animated`, animationName);
      resolve('Animation ended');

    }
    node.addEventListener('animationend', handleAnimationEnd, { once: true });
    //if (typeof callback === 'function') callback()
  });
//Default loader

const theme_loader = '<div class="sm-loader"></div>';

const default_loader = '<svg aria-hidden="true" role="status" class="inline w-4 h-4 me-3 text-white animate-spin" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="#E5E7EB"/><path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentColor"/></svg>Loading...';

const pageLoader = '<div class="text-center">' + default_loader + '</div>';

//General Class - Main Configurations for watermelon usage
class General {
  constructor() {
    new Geolocation().getLocation();
    this.controller = new AbortController();
    this.signal = this.controller.signal;
    document.onreadystatechange = function () {
      if (document.readyState !== "complete") {
        NProgress.start();
        document.querySelector(
          "body").style = "pointer-events: none; opacity:.2;";
      } else {
        document.querySelector(
          "body").style = "";
        NProgress.done();
      }
      if (window.speechSynthesis.getVoices().length == 0) {
        window.speechSynthesis.addEventListener("voiceschanged", function () {
          speechSynthesis.onvoiceschanged = "Microsoft Zira Desktop - English (United States)";
        });
      }
    };
  }

  abortRequest() {
    this.controller.abort();
  }

  secure_token(ref, key) {
    var formData = new FormData();
    formData.append('fingerprint', radar._Tracker().deviceFingerPrint);
    formData.append('url', this.getCurrentUrl());
    formData.append('request', 'challenge');
    this.ajaxFormData(null, 'POST', ref, formData, null, null, function (data) {
      if (typeof data.token !== 'undefined') {
        storage.set(key, data.token);
      }
    });
  }

  is_token_stored(token) {
    var stored = storage.get(token);
    if (stored !== undefined && stored !== '' && stored !== 'null' && stored !== null) {
      return true;
    }
    return false;
  }

  countdown(selector, minutes, units, callback) {
    const startTime = new Date().getTime();
    const endTime = startTime + minutes * 60000;

    const timeElement = document.querySelector(selector);

    let intervalId = setInterval(() => {
      const now = new Date().getTime();
      const distance = endTime - now;

      let timeString = '';
      if (units.includes('hours')) {
        const hours = Math.floor(distance / 3600000);
        timeString += `${hours.toString().padStart(2, '0')}:`;
      }
      if (units.includes('minutes')) {
        const minutes = Math.floor((distance % 3600000) / 60000);
        timeString += `${minutes.toString().padStart(2, '0')}:`;
      }
      if (units.includes('seconds')) {
        const seconds = Math.floor((distance % 60000) / 1000);
        timeString += `${seconds.toString().padStart(2, '0')}`;
      }

      if (distance < 0) {
        timeString = units.map(unit => '00').join(':');
      }

      timeElement.textContent = timeString;

      if (distance < 0) {
        clearInterval(intervalId);
        callback();
      }
    }, 1000);
  }



  getBase() {
    var script;
    if (document.currentScript) {
      script = document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName('script');
      script = scripts[scripts.length - 1].src;
    }
    var x = script.split('/');
    var urlBase = '';
    for (const path of x) {
      if (typeof path != 'undefined') {
        if (path == 'asset') {
          break;
        } else {
          urlBase += path + '/';
        }
      }
    }
    return urlBase;
  }
  currentPage() {
    return window.location.href;
  }
  redirect(url) {
    window.location = url;
  }
  reload() {
    document.location.reload()
  }
  getCurrentUrl() {
    let url = new URL(window.location.href);
    return url.href;
  }
  async ajaxFormData(formID, type, url, data, btid = null, buttonName = null, successCallback = null, loader = 'default') {
    try {
      // Show loader
      data.append('latitude', storage.get('latitude'));
      data.append('longitude', storage.get('longitude'));

      if (btid !== null && buttonName !== null) {
        NProgress.start();
      }
      if (btid !== null && btid !== '' && typeof btid !== 'undefined') {
        $(btid).removeClass("btn-dim");
        $(btid).attr('disabled', true);
        $(btid).attr('style', 'opacity: 0.5');
        document.querySelector(btid).style.pointerEvents = "none";
        switch (loader) {
          case 'centerLoader':
            $(btid).html(default_loader);
            break;
          case 'themeLoader':
            $(btid).html(theme_loader);
            break;
          case 'pageLoader':
            $(btid).html(pageLoader);
            break;
          default:
            $(btid).html(loader);
        }
      }

      const response = await fetch(url, {
        method: type,
        body: data,
        signal: this.signal,
        timeout: 10000,
      });

      const responseData = await response.json();

      if (response.ok && responseData.status === 200) {
        // Handle success response
        if (buttonName !== null) {
          $(btid).html(buttonName);
        } else {
          $('#maloaders').remove();
        }
        if (btid !== null && btid !== '' && typeof btid !== 'undefined') {
          $(btid).attr("disabled", false);
          $(btid).css("opacity", 2.5);
          document.querySelector(btid).style = "";
        }
        if (typeof successCallback === 'function') {
          successCallback(responseData, buttonName);
        }
        if (formID !== null && buttonName !== null && btid !== null) {
          NProgress.done();
        }
      } else {
        // Handle error response
        if (btid !== null && btid !== '' && typeof btid !== 'undefined') {
          $(btid).attr("disabled", false);
          $(btid).css("opacity", 2.5);
          document.querySelector(btid).style = "";
        }
        if (buttonName !== null && buttonName !== '' && typeof buttonName !== 'undefined') {
          $(btid).html(buttonName);
        } else {
          $('#maloaders').remove();
        }
        gToast.error(responseData.error);
        if (formID !== null) {
          animateCSS(formID, 'shake');
        }
        if (formID !== null && buttonName !== null && btid !== null) {
          NProgress.done();
        }
      }
    } catch (error) {
      if (btid !== null) {
        $(btid).attr("disabled", false);
        $(btid).css("opacity", 2.5);
        document.querySelector(btid).style = "";
      }
      if (buttonName !== null && buttonName !== '' && typeof buttonName !== 'undefined') {
        $(btid).html(buttonName);
      } else {
        $('#maloaders').remove();
      }
      if (formID !== null) {
        animateCSS(formID, 'shake');
      }
      if (formID !== null && buttonName !== null && btid !== null) {
        NProgress.done();
      }

      if (error.name === 'AbortError') {
        //do nothing
        return;
      }
      else if (error.name === 'TimeoutError') {
        gToast.error('Timeout reached. Please try again');
      } else {
        //'System error and our engineers has been notified of it. Please kindly bear with us.'
        gToast.error(error);
      }

    }
  }
  modalNote(title, message, type = 'info') {
    // Define SVG icons for each message type
    const icons = {
      success: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`,
      failure: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>`,
      warning: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" /></svg>`,
      info: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z" /></svg>`
    };

    // Select the appropriate icon based on type, default to info
    const selectedIcon = icons[type.toLowerCase()] || icons.info;

    return `
      <div id="modalNote" class="fixed inset-0 z-50 hidden overflow-y-auto flex items-center justify-center bg-gray-900/50 p-4 backdrop-blur-sm transition-opacity duration-300" role="dialog" aria-modal="true">
        <div class="custom-modal-dialog medium animate__animated animate__slideInLeft overflow-hidden rounded-2xl glass-effect shadow-lg">
          <button type="button" class="absolute top-4 right-4 z-10 text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 clickable" data-modal-close>
            <span class="sr-only">Close</span>
            âœ•
          </button>
          <div class="w-full p-6">
            <div class="flex items-center justify-between mb-4">
              <div class="flex items-center gap-3">
                <div class="w-10 h-10 rounded-full flex items-center justify-center bg-gradient-to-br from-purple-500 to-blue-500 text-white">
                  ${selectedIcon}
                </div>
                <h3 class="text-lg font-semibold text-white">${title}</h3>
              </div>
            </div>

            <div class="text-sm text-gray-300">
              ${message}
            </div>
          </div>
        </div>
      </div>
    `;
  }

  greetUser() {
    var greeting;
    var time = new Date().getHours();
    if (time < 10) {
      greeting = general.morning;
    } else if (time < 20) {
      greeting = general.day;
    } else {
      greeting = general.evening;
    }
    if ($("#app-greetings").length) {
      $("#app-greetings").append(greeting);
    }
  }
  cache(data) {
    return data;
  }
  arrayStringToInt(data) {
    return data.map(i => Number(i));
  }
  getCurrency(key) {
    let currency = {
      'NGN': 'â‚¦',
      'USD': '$',
    }
    return currency[key];
  }
  delay(callback, ms) {
    var timer = 0;
    return function (...args) {
      clearTimeout(timer)
      args = arguments;
      timer = setTimeout(callback.bind(this, ...args), ms || 0)
    }
  }
  sleep(milliseconds) {
    const date = Date.now();
    let currentDate = null;
    do {
      currentDate = Date.now();
    } while (currentDate - date < milliseconds);
  }
  countIntArray(value) {
    if (Number.isInteger(value)) {
      var arrayOfDigits = Array.from(String(value), Number);
      var count = 0;
      for (var i = 0; i < arrayOfDigits.length; ++i) {
        count++;
      }
      return count;
    } else {
      return false;
    }
  }
  speak(text, onendCallBack = null) {
    if (typeof window.speechSynthesis === 'undefined' && !window.speechSynthesis) {
      //Webview not supported yet
      //Run API instead
      this.ajaxFormData(null, 'POST', this.getBase + 'src/Nerves/voice', { request: 'compute', text: text }, null, null, function (data) {
        quenee.push(data.sound);
        inPlayer(quenee);
        function inPlayer(quene) {
          if (quene.length > 0) {
            //check if audio is playing currently
            if (timee === 0) {
              //audio is not playing, play it
              const audio = new Audio(quenee[0]);
              audio.play();
              var clearr = setInterval(function () {
                timee = audio.currentTime;
                if (audio.duration === audio.currentTime) {
                  audio.currentTime = 0;
                  clearInterval(clearr);
                  timee = 0;
                }
              }, 100);
              audio.addEventListener('ended', function () {
                quene.shift();
                (new General).ajaxFormData(null, 'POST', this.getBase + 'src/Nerves/voice', { request: 'trash', text: data.sound }, null, null, null, null);
                timee = 0;
                inPlayer(quene);
              })
            }
          }
        }
      })
    } else {
      let english_voice = window.speechSynthesis.getVoices().filter(function (voice) {
        return voice.name == 'Microsoft Zira Desktop - English (United States)';
      })[0];
      var utter = new SpeechSynthesisUtterance();
      utter.rate = 1;
      utter.pitch = 0.5;
      utter.text = this.filter(text);
      utter.voice = english_voice;
      utter.onend = function () {
        if (typeof onendCallBack === 'function' && onendCallBack !== null) {
          onendCallBack();
        }
      };
      window.speechSynthesis.speak(utter);
      text = null;
    }
  }
  filter(str) {
    if ((str === null) || (str === ''))
      return '';
    else {
      var doc = new DOMParser().parseFromString(str, 'text/html');
      return doc.body.textContent || "";
    }
  }
  getDeviceType() {
    const userAgent = navigator.userAgent;
    const isMobile = (
      userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i) ||
      (window.matchMedia('(max-width: 768px)').matches && userAgent.match(/Mobile/i)) || // Small screen devices with "Mobile" in UA
      (window.matchMedia('(pointer: coarse)').matches && !userAgent.match(/Windows NT|Macintosh|Linux/i)) // Touch devices without Windows, Mac, or Linux UA
    );
    const isLinux = (
      userAgent.match(/Linux/i) && !userAgent.match(/Android/i) // Linux devices excluding Android
    );
    const isUnusualDevice = (
      userAgent.match(/Bot|Crawler|Spider|Scan|Monitor|Curl|Wget|Lynx|Shoutcast/i) || // Bots and crawlers
      (navigator.userAgentData && navigator.userAgentData.brands.length === 0) || // Empty user agent data
      (navigator.vendor === '' && navigator.appVersion === '') // Empty vendor and app version
    );
    if (isUnusualDevice) {
      console.log('Unusual device detected. Access blocked.');
      return null; // or return a specific message
    }
    if (isLinux) {
      return 'desktop'; // Linux devices are typically desktops
    }
    return isMobile ? 'mobile' : 'desktop';
  }
  readFile(input, selector) {
    if (input.files && input.files[0]) {
      var reader = new FileReader();

      reader.onload = function (e) {
        $(selector).attr('src', e.target.result);
      }
      reader.readAsDataURL(input.files[0]);
    }
  }
  download_file(fileURL, fileName) {
    // for non-IE
    if (!window.ActiveXObject) {
      var save = document.createElement('a');
      save.href = fileURL;
      save.target = '_blank';
      var filename = fileURL.substring(fileURL.lastIndexOf('/') + 1);
      save.download = fileName || filename;
      if (navigator.userAgent.toLowerCase().match(/(ipad|iphone|safari)/) && navigator.userAgent.search("Chrome") < 0) {
        document.location = save.href;
        // window event not working here
      } else {
        var evt = new MouseEvent('click', {
          'view': window,
          'bubbles': true,
          'cancelable': false
        });
        save.dispatchEvent(evt);
        (window.URL || window.webkitURL).revokeObjectURL(save.href);
        gToast.success('Downloaded successfully.');
      }
    }
    // for IE < 11
    else if (!!window.ActiveXObject && document.execCommand) {
      var _window = window.open(fileURL, '_blank');
      _window.document.close();
      _window.document.execCommand('SaveAs', true, fileName || fileURL)
      gToast.success('Downloaded successfully.');
      _window.close();
    }
  }
  generateNumber(otpLength = 6) {
    let baseNumber = Math.pow(10, otpLength - 1);
    let number = Math.floor(Math.random() * baseNumber);
    /*
    Check if number have 0 as first digit
    */
    if (number < baseNumber) {
      number += baseNumber;
    }
    return number;
  }
  getExt(fname) {
    var pos = fname.lastIndexOf(".");
    var strlen = fname.length;
    if (pos != -1 && strlen != pos + 1) {
      var ext = fname.split(".");
      var len = ext.length;
      var extension = ext[len - 1].toLowerCase();
    } else {
      extension = "No extension found";
    }
    return extension;
  }
  player(sound, callback = null) {
    var audio = new Audio(sound);
    if (typeof callback === 'function') {
      callback(audio);
    }
    audio.play();
    audio.volume = 1;
  }
  getParentUrl() {
    var isInIframe = (parent !== window), parentUrl = null;
    if (isInIframe) {
      parentUrl = document.referrer;
    }
    if (parentUrl === '' || parentUrl === null) {
      return storage.get('clara_currents');
    }
    return parentUrl;
  }
  pdfView(binary) {
    var pdfDoc = null,
      pageNum = 1,
      pageRendering = false,
      pageNumPending = null,
      scale = 1.2,
      canvas = document.getElementById('the-canvas'),
      ctx = canvas.getContext('2d');

    function renderPage(num) {
      pageRendering = true;
      pdfDoc.getPage(num).then(function (page) {
        var viewport = page.getViewport({ scale: scale });
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        var renderContext = {
          canvasContext: ctx,
          viewport: viewport
        };
        var renderTask = page.render(renderContext);
        renderTask.promise.then(function () {
          pageRendering = false;
          if (pageNumPending !== null) {
            renderPage(pageNumPending);
            pageNumPending = null;
          }
        });
      });
      document.getElementById('page_num').textContent = num;
    }
    function queueRenderPage(num) {
      if (pageRendering) {
        pageNumPending = num;
      } else {
        renderPage(num);
      }
    }
    function onPrevPage() {
      if (pageNum <= 1) {
        return;
      }
      pageNum--;
      queueRenderPage(pageNum);
    }
    document.getElementById('prev').addEventListener('click', onPrevPage);
    function onNextPage() {
      if (pageNum >= pdfDoc.numPages) {
        return;
      }
      pageNum++;
      queueRenderPage(pageNum);
    }
    document.getElementById('next').addEventListener('click', onNextPage);


    var zoominbutton = document.getElementById("zoominbutton");
    zoominbutton.onclick = function () {
      scale = scale + 0.5;
      queueRenderPage(pageNum);
    }

    var zoomoutbutton = document.getElementById("zoomoutbutton");
    zoomoutbutton.onclick = function () {
      if (scale <= 1.0) {
        return;
      }
      scale = scale - 1.0;
      queueRenderPage(pageNum);
    }
    var pdfData = atob(binary);
    pdfjsLib.getDocument({ data: pdfData }).promise.then(function (pdfDoc_) {
      pdfDoc = pdfDoc_;
      document.getElementById('page_count').textContent = pdfDoc.numPages;

      // Initial/first page rendering
      renderPage(pageNum);
    });
  }
  loadScript(url, callback) {
    var script = document.createElement("script");
    script.type = "text/javascript";

    if (script.readyState) {  //IE
      script.onreadystatechange = function () {
        if (script.readyState == "loaded" ||
          script.readyState == "complete") {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else {  //Others
      script.onload = function () {
        callback();
      };
    }
    script.src = url;
    document.getElementsByTagName("head")[0].appendChild(script);
  }
  isNumber(x, noStr) {
    return (
      (typeof x === 'number' || x instanceof Number || (!noStr && x && typeof x === 'string' && !isNaN(x))) &&
      isFinite(x)
    ) || false;
  }
  isEmpty(value) {
    return (
      (value == null) ||
      (value.hasOwnProperty('length') && value.length === 0) ||
      (value.constructor === Object && Object.keys(value).length === 0)
    )
  }

  setupFileUpload({
    inputId,
    dropZoneSelector,
    fileNamesId,
    errorMessageId,
    uploadUrl,
    deleteUrl,
    multiple = false,
    maxFiles = 5,
    allowedTypes = [
      'image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp',
      'audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/mp4', 'audio/flac',
      'video/mp4', 'video/webm', 'video/ogg', 'video/quicktime',
      'application/pdf'
    ],
    extraHeader = {},
    maxSize = 20 * 1024 * 1024, // 20MB
    csrfSelector = 'input[name="_csrf"]',
    onSuccess = () => { }
  }) {
    // Get all necessary DOM elements for the uploader.
    const fileInput = document.getElementById(inputId);
    const dropZone = document.querySelector(dropZoneSelector);
    const errorMessage = document.getElementById(errorMessageId);
    const fileNamesContainer = document.getElementById(fileNamesId);

    // If any required element is missing, log an error and exit.
    if (!fileInput || !dropZone || !errorMessage || !fileNamesContainer) {
      console.error('Missing required elements:', { fileInput, dropZone, errorMessage, fileNamesContainer });
      return;
    }

    // Set the multiple attribute on the file input based on the function parameter.
    fileInput.multiple = multiple;

    // Initialize Flow.js with the dynamic headers.
    const flow = new Flow({
      target: uploadUrl,
      chunkSize: 1024 * 1024, // 1MB chunks
      simultaneousUploads: 1,
      query: {
        'csrf_name': document.querySelector('input[name="csrf_name"]')?.value || '',
        'csrf_value': document.querySelector('input[name="csrf_value"]')?.value || '',
        'property_id': storage.get('property_id')
      }
    });

    // Track files and their states (e.g., progress, elements).
    let fileStates = [];

    // Helper function to show an error message in the designated area.
    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.classList.remove('hidden');
      setTimeout(() => errorMessage.classList.add('hidden'), 10000); // Auto-hide after 10s
    }

    // Helper function to remove a file from the UI and internal state.
    function removeFile(fileName) {
      const fileState = fileStates.find(fs => fs.name === fileName);
      if (fileState) {
        fileState.element.style.animation = 'slideInUp 0.4s ease-out reverse';
        setTimeout(() => {
          fileState.element.remove();
          fileStates = fileStates.filter(fs => fs.name !== fileName);
          if (fileStates.length === 0) {
            fileNamesContainer.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400 text-center">No files</p>';
          }
        }, 400);
        const flowFile = flow.files.find(f => f.name === fileName);
        if (flowFile) flow.removeFile(flowFile);
        fileInput.value = ''; // Clear input to allow new uploads
      }
    }

    // Determines the icon and text for a given file type.
    function getFileTypeInfo(file) {
      const type = file.type.split('/')[0];
      let iconClass = 'fas fa-file file-type-document';
      let typeText = 'Document';
      let progressClass = 'progress-warning';
      if (type === 'image') {
        iconClass = 'fas fa-image file-type-image';
        typeText = 'Image';
        progressClass = 'progress-success';
      } else if (type === 'audio') {
        iconClass = 'fas fa-music file-type-audio';
        typeText = 'Audio';
        progressClass = 'progress-purple';
      } else if (type === 'video') {
        iconClass = 'fas fa-video file-type-video';
        typeText = 'Video';
        progressClass = 'progress-info';
      }
      return { iconClass, typeText, progressClass };
    }

    // Formats file size into a human-readable string.
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 bytes';
      const units = ['B', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(1024));
      const size = (bytes / Math.pow(1024, i)).toFixed(1);
      return `${parseFloat(size)} ${units[i]}`;
    }

    // Updates the file list display on the page.
    function updateFileList(files) {
      if (fileStates.length === 0 && files.length === 0) {
        fileNamesContainer.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400 text-center">No files</p>';
        return;
      }
      if (fileStates.length === 0 && files.length > 0) {
        fileNamesContainer.innerHTML = '';
      }

      Array.from(files).forEach((file, index) => {
        if (fileStates.some(fs => fs.name === file.name)) return;

        const fileItem = document.createElement('div');
        fileItem.className = 'file-item flex items-center justify-between p-3 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-600 shadow-sm';
        fileItem.id = `file-item-${fileStates.length}-${index}`;

        const { iconClass, typeText, progressClass } = getFileTypeInfo(file);
        const fileInfo = document.createElement('div');
        fileInfo.className = 'flex items-center space-x-3 flex-1 min-w-0';
        fileInfo.innerHTML = `
                <div class="flex-shrink-0">
                    <i class="${iconClass} text-2xl"></i>
                </div>
                <div class="flex-1 min-w-0">
                    <p class="text-sm font-medium text-gray-900 dark:text-gray-100 truncate">${file.name}</p>
                    <div class="flex items-center justify-between">
                        <p class="text-xs text-gray-500 dark:text-gray-400">${formatFileSize(file.size)} â€¢ ${typeText}</p>
                        <p class="progress-text text-xs text-green-600 dark:text-green-400 font-medium">0%</p>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar ${progressClass}" style="width: 0%"></div>
                    </div>
                </div>
            `;

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'remove-btn flex-shrink-0 ml-3 p-2 text-gray-400 hover:text-red-500 dark:hover:text-red-400 rounded-full';
        cancelBtn.innerHTML = '<i class="fas fa-times text-sm"></i>';

        fileItem.appendChild(fileInfo);
        fileItem.appendChild(cancelBtn);
        fileNamesContainer.appendChild(fileItem);

        const progressBar = fileItem.querySelector('.progress-bar');
        const progressText = fileItem.querySelector('.progress-text');
        const progressContainer = fileItem.querySelector('.progress-container');

        const fileState = {
          file: null,
          name: file.name,
          url: null,
          element: fileItem,
          progressBar,
          progressText,
          progressContainer
        };
        fileStates.push(fileState);

        cancelBtn.addEventListener('click', async () => {
          removeFile(file.name);
          if (fileState.url) {
            try {
              const response = await fetch(deleteUrl, {
                method: 'DELETE',
                headers: {
                  'Content-Type': 'application/json',
                  'X-CSRF-TOKEN': document.querySelector(csrfSelector)?.value || ''
                },
                body: JSON.stringify({ url: fileState.url })
              });
              if (!response.ok) console.error('Failed to delete file:', fileState.url);
            } catch (e) {
              console.error('Delete request error:', e);
            }
          }
        });
      });
    }

    // The main function to handle files from a drop or selection.
    function handleFiles(files) {
      if (!files || files.length === 0) {
        showError('No files selected.');
        return;
      }
      if (!multiple && files.length > 1) {
        showError('Only one file is allowed in single-file mode.');
        fileInput.value = '';
        return;
      }
      if (fileStates.length + files.length > maxFiles) {
        showError(`Maximum ${maxFiles} file${maxFiles > 1 ? 's' : ''} allowed.`);
        fileInput.value = '';
        return;
      }

      const validFiles = Array.from(files).filter(file => {
        if (!allowedTypes.includes(file.type)) {
          showError(`Invalid file type for ${file.name}. Allowed types are: ${allowedTypes.join(', ')}`);
          return false;
        }
        if (file.size > maxSize) {
          showError(`File ${file.name} exceeds ${formatFileSize(maxSize)}.`);
          return false;
        }
        return true;
      });

      if (validFiles.length === 0) {
        fileInput.value = '';
        return;
      }

      // Update the file list UI.
      updateFileList(validFiles);

      errorMessage.classList.add('hidden');
      validFiles.forEach(file => {
        const flowFile = flow.addFile(file);
        const fileState = fileStates.find(fs => fs.name === file.name);
        if (fileState) {
          fileState.file = flowFile; // Link the Flow.js file to our state.
        }
      });

      // Start the upload process.
      flow.upload();
    }

    // Event listeners for file input and drag-and-drop.
    fileInput.addEventListener('change', (event) => {
      const files = multiple ? event.target.files : [event.target.files[0]].filter(f => f);
      handleFiles(files);
    });
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('border-wake-color-1');
    });
    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('border-wake-color-1');
    });
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('border-wake-color-1');
      const files = multiple ? e.dataTransfer.files : [e.dataTransfer.files[0]].filter(f => f);
      fileInput.files = e.dataTransfer.files;
      handleFiles(files);
    });

    // Flow.js event listeners to track upload progress and status.
    flow.on('fileAdded', (file) => {
      // This event is fired after the file is added to the Flow.js queue.
    });

    flow.on('fileProgress', (file) => {
      const fileState = fileStates.find(fs => fs.name === file.name);
      if (fileState) {
        const progress = (file.sizeUploaded() / file.size * 100).toFixed(0);
        fileState.progressBar.style.width = `${progress}%`;
        fileState.progressText.textContent = `${progress}%`;
      }
    });

    flow.on('fileSuccess', (file, message) => {
      try {
        const response = JSON.parse(message);
        if (response.status === 200) {
          const fileState = fileStates.find(fs => fs.name === file.name);
          if (fileState) {
            fileState.url = response.url;
            fileState.progressBar.style.width = '100%';
            fileState.progressText.textContent = 'Complete';
          }
          if (flow.files.every(f => f.isComplete())) {
            fileInput.dataset.fileUrls = JSON.stringify(fileStates.map(fs => fs.url).filter(url => url));
            onSuccess(fileStates.filter(fs => fs.url).map(fs => ({ name: fs.name, url: fs.url })));
          }
        } else {
          showError(`Upload failed for ${file.name}: ${response.error}`);
          removeFile(file.name);
        }
      } catch (e) {
        showError(`Failed to parse server response for ${file.name}: ${e.message}`);
        removeFile(file.name);
      }
    });

    flow.on('fileError', (file, message) => {
      let errorMsg = 'Unknown error';
      try {
        const responseError = JSON.parse(message);
        errorMsg = responseError.error || errorMsg;
      } catch (e) {
        errorMsg = e.message;
      }
      showError(`Upload failed for ${file.name}: ${errorMsg}`);
      removeFile(file.name);
    });

    // Return the Flow instance for external access if needed.
    return flow;
  }




}
class NextPrev {
  constructor(className, prevId, nextId, currentTab) {
    this.className = className;
    this.prevName = prevId;
    this.nextName = nextId;
    this.currentTab = currentTab;
    this.trigger = false;

  }
  showTab() {
    var pageEle = document.getElementsByClassName(this.className);
    pageEle[this.currentTab].style.display = "block";
    if (this.currentTab == 0) {
      document.getElementById(this.prevName).style.display = "none";
    }
    else {
      document.getElementById(this.prevName).style.display = "inline";
    }
    if (this.currentTab == (pageEle.length - 1)) {
      document.getElementById(this.prevName).innerHTML = "Prev";
    }
    else {
      document.getElementById(this.nextName).innerHTML = "Next";
    }
    this.changeStepIndicator(this.currentTab)
  }
  changeStepIndicator(currentTab) {
    const highlightedItems = document.querySelectorAll(".step");
    highlightedItems.forEach((userItem) => {
      userItem.children[0].className = userItem.children[0].className.replace("step-header rounded-full bg-primary text-white dark:bg-accent", "step-header rounded-full bg-slate-200 text-slate-800 dark:bg-navy-500 dark:text-white");
    });
    var pageEle = document.querySelectorAll(".step");
    pageEle[currentTab].children[0].className = "step-header rounded-full bg-primary text-white dark:bg-accent";
  }
  nextPrev(stepNo, callback) {
    var pageEle = document.getElementsByClassName(this.className);
    var remcurrentTab = stepNo + this.currentTab;
    let progress = pageEle.length - remcurrentTab;
    var btn = document.getElementById(this.nextName);

    if ((progress === 1 || progress === 0) && stepNo === 1) {
      btn.innerHTML = "Submit";
      btn.setAttribute('type', 'submit');
      this.trigger = true;
    } else {
      btn.innerHTML = "Next";
      btn.removeAttribute('type');
      this.trigger = false;
    }
    if (this.trigger && remcurrentTab >= pageEle.length) {
      if (typeof callback === 'function') {
        callback();
      }
      return;
    }
    pageEle[this.currentTab].style.display = "none";
    this.currentTab = remcurrentTab;
    this.showTab();
  }
}
// LoadJS with duplicate script checking
let loadjs = (function () {
  // Default empty function
  const noop = function () { };

  // Storage objects
  const bundleIdCache = {};
  const bundleResultCache = {};
  const bundleCallbackQueue = {};

  /**
   * Publish bundle load event
   * @param {string} bundleId 
   * @param {any} data 
   */
  function publish(bundleId, data) {
    if (bundleId) {
      const subscribers = bundleCallbackQueue[bundleId];
      bundleResultCache[bundleId] = data;

      if (subscribers) {
        while (subscribers.length) {
          subscribers[0](bundleId, data);
          subscribers.splice(0, 1);
        }
      }
    }
  }

  /**
   * Execute callbacks
   * @param {object} args 
   * @param {array} errors 
   */
  function executeCallbacks(args, errors) {
    if (args.call) {
      args = { success: args };
    }

    if (errors.length) {
      (args.error || noop)(errors);
    } else {
      (args.success || noop)(args);
    }
  }

  /**
   * Check if script/style is already loaded
   * @param {string} path 
   * @returns {boolean}
   */
  function isAlreadyLoaded(path) {
    const scripts = document.getElementsByTagName('script');
    const links = document.getElementsByTagName('link');
    const images = document.getElementsByTagName('img');

    // Check for scripts
    for (let i = 0; i < scripts.length; i++) {
      if (scripts[i].src === path) {
        return true;
      }
    }

    // Check for stylesheets
    for (let i = 0; i < links.length; i++) {
      if (links[i].href === path) {
        return true;
      }
    }

    // Check for images
    for (let i = 0; i < images.length; i++) {
      if (images[i].src === path) {
        return true;
      }
    }

    return false;
  }

  /**
   * Load individual file
   * @param {string} path 
   * @param {function} callbackFn 
   * @param {object} args 
   * @param {number} numTries 
   */
  function loadFile(path, callbackFn, args, numTries) {
    const doc = document;
    const async = args.async;
    const maxTries = (args.numRetries || 0) + 1;
    const beforeCallbackFn = args.before || noop;

    const pathStripped = path.replace(/[\?|#].*$/, '');
    const pathNormalized = path.replace(/^(css|img)!/, '');

    numTries = numTries || 0;

    // Check if already loaded
    if (isAlreadyLoaded(pathNormalized)) {
      callbackFn(path, 'ok', true);
      return;
    }

    let element;
    let supportsPrefetch;

    if (/(^css!|\.css$)/.test(pathStripped)) {
      element = doc.createElement('link');
      element.rel = 'stylesheet';
      element.href = pathNormalized;

      // Check for prefetch support
      supportsPrefetch = ('hideFocus' in element);
      if (supportsPrefetch && element.relList) {
        supportsPrefetch = false;
        element.rel = 'preload';
        element.as = 'style';
      }
    } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathStripped)) {
      element = doc.createElement('img');
      element.src = pathNormalized;
    } else {
      element = doc.createElement('script');
      element.src = path;
      element.async = async === undefined ? true : async;
    }

    // Add event listeners
    element.onload = element.onerror = element.onbeforeload = function (event) {
      const type = event.type[0];

      // Handle stylesheet prefetch
      if (supportsPrefetch) {
        try {
          if (!element.sheet.cssText.length) {
            type = 'e';
          }
        } catch (e) {
          if (e.code !== 18) {
            type = 'e';
          }
        }
      }

      if (type === 'e') {
        if ((numTries + 1) < maxTries) {
          return loadFile(path, callbackFn, args, numTries + 1);
        }
      } else if (element.rel === 'preload' && element.as === 'style') {
        return element.rel = 'stylesheet';
      }

      callbackFn(path, type, event.defaultPrevented);
    };

    // Insert into document if beforeCallbackFn returns true
    if (beforeCallbackFn(path, element) !== false) {
      doc.head.appendChild(element);
    }
  }

  /**
   * Main public API
   * @param {string|array} paths 
   * @param {string|object} arg1 
   * @param {object} arg2 
   */
  function loadjs(paths, arg1, arg2) {
    let bundleId;
    let args;

    if (arg1 && arg1.trim) {
      bundleId = arg1;
    }

    args = (bundleId ? arg2 : arg1) || {};

    // Check for bundle id existence
    if (bundleId) {
      if (bundleId in bundleIdCache) {
        throw 'LoadJS: Bundle already exists';
      }
      bundleIdCache[bundleId] = true;
    }

    function loadFn(resolve, reject) {
      loadFiles(paths, function (pathsNotFound) {
        executeCallbacks(args, pathsNotFound);
        resolve && executeCallbacks({ success: resolve, error: reject }, pathsNotFound);
        publish(bundleId, pathsNotFound);
      }, args);
    }

    if (args.returnPromise) {
      return new Promise(loadFn);
    } else {
      loadFn();
    }
  }

  /**
   * Load multiple files
   * @param {array} paths 
   * @param {function} callbackFn 
   * @param {object} args 
   */
  function loadFiles(paths, callbackFn, args) {
    paths = paths.push ? paths : [paths];

    let numWaiting = paths.length;
    let numFailed = 0;
    const pathsNotFound = [];

    function loadFileCallback(path, type, isSkipped) {
      if (type === 'e') {
        pathsNotFound.push(path);
      }
      if (type === 'b') {
        if (!isSkipped) {
          pathsNotFound.push(path);
        }
      }

      numWaiting--;
      if (!numWaiting) {
        callbackFn(pathsNotFound);
      }
    }

    for (let i = 0; i < paths.length; i++) {
      loadFile(paths[i], loadFileCallback, args);
    }
  }

  // Public API
  loadjs.ready = function (deps, callback) {
    subscribeToBundle(deps, function (depsNotFound) {
      executeCallbacks(callback, depsNotFound);
    });
    return loadjs;
  };

  loadjs.done = function (bundleId) {
    publish(bundleId, []);
  };

  loadjs.reset = function () {
    bundleIdCache = {};
    bundleResultCache = {};
    bundleCallbackQueue = {};
  };

  loadjs.isDefined = function (bundleId) {
    return bundleId in bundleIdCache;
  };

  /**
   * Subscribe to bundle load event
   * @param {string|array} bundleIds 
   * @param {function} callbackFn 
   */
  function subscribeToBundle(bundleIds, callbackFn) {
    bundleIds = bundleIds.push ? bundleIds : [bundleIds];

    let depsNotFound = [];
    let numWaiting = bundleIds.length;
    let numLoaded = 0;

    function subscribeCallback(bundleId, pathsNotFound) {
      if (pathsNotFound.length) {
        depsNotFound.push(bundleId);
      }
      numWaiting--;
      if (!numWaiting) {
        callbackFn(depsNotFound);
      }
    }

    for (let i = 0; i < bundleIds.length; i++) {
      const bundleId = bundleIds[i];

      const result = bundleResultCache[bundleId];
      if (result) {
        subscribeCallback(bundleId, result);
      } else {
        (bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [])
          .push(subscribeCallback);
      }
    }
  }

  return loadjs;
})();
//Load all other scripts available

class AudioPlayer {
  static instance;

  constructor(name) {
    this.name = name;
    this.audioQueue = [];
    this.currentAudio = null;
    this.currentSoundIndex = 0;
    this.isRepeating = false;
    this.isPlaying = false;
    this.storedQueue = [];
    this.eventListeners = { ended: [] }; // Store callbacks for 'ended' event
  }

  static getInstance(name) {
    if (!AudioPlayer.instance) {
      AudioPlayer.instance = new AudioPlayer(name);
    }
    return AudioPlayer.instance;
  }

  // Add a listener for the 'ended' event
  onEnded(callback) {
    if (typeof callback === 'function') {
      this.eventListeners.ended.push(callback);
    }
  }

  // Remove a listener for the 'ended' event
  offEnded(callback) {
    this.eventListeners.ended = this.eventListeners.ended.filter(cb => cb !== callback);
  }

  // Trigger all 'ended' event listeners
  emitEnded(audioUrl) {
    this.eventListeners.ended.forEach(callback => callback(audioUrl));
  }

  isEmpty(value) {
    return (
      value == null ||
      (value.hasOwnProperty('length') && value.length === 0) ||
      (value.constructor === Object && Object.keys(value).length === 0)
    );
  }

  playAudio(url) {
    if (!this.isEmpty(url)) {
      const audio = new Audio(url);
      audio.dataset.url = url; // Store the URL for later use in the ended event
      this.audioQueue.push(audio);

      if (this.isRepeating) {
        this.storedQueue.push(audio);
      }

      if (!this.currentAudio) {
        this.playNextAudio();
      }
    }
  }

  playNextAudio() {
    if (this.currentAudio && !this.currentAudio.paused && !this.currentAudio.ended) {
      return;
    }

    if (this.audioQueue.length === 0) {
      if (this.isRepeating && this.storedQueue.length > 0) {
        this.currentSoundIndex = 0;
        this.audioQueue.push(...this.storedQueue);
        this.currentAudio = null;
        if (this.audioQueue.length > 0) {
          this.playNextAudio();
        }
      }
      return;
    }

    this.currentAudio = this.audioQueue.shift();
    this.currentAudio.addEventListener('play', () => {
      this.isPlaying = true;
    });
    this.currentAudio.addEventListener('pause', () => {
      this.isPlaying = false;
    });
    this.currentAudio.addEventListener('ended', () => {
      // Emit the custom 'ended' event with the audio URL
      this.emitEnded(this.currentAudio.dataset.url);
      this.currentAudio = null;
      this.currentSoundIndex++;
      this.playNextAudio();
    });
    this.currentAudio.play();
  }

  stopAudio() {
    if (this.currentAudio) {
      this.currentAudio.pause();
      this.currentAudio = null;
    }
    this.audioQueue = [];
    this.storedQueue = [];
    this.currentSoundIndex = -1;
    this.isRepeating = false;
    this.isPlaying = false;
  }

  setRepeat(isRepeating) {
    this.isRepeating = isRepeating;
  }
}

class ToastNotification {

  init(message, type = 'info') {
    const styles = this.getTypeStyles(type);
    const template = this.getIconTemplate(type);

    UIkit.notification({
      message: '<div class=\'flex gap-5 items-center\'> <div class=\'rounded-full ' + styles.bg + ' p-1.5 inline-flex ring-offset-1\'> ' + template + ' </div> <div class=\'flex-1\'> ' + message + ' </div> </div> ',
      pos: 'top-right',
      timeout: '5000'
    })
  }

  getIconTemplate(type) {
    const icons = {
      success: `<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>`,
      error: `<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>`,
      warning: `<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>`,
      info: `<svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`
    };
    return icons[type] || icons.info;
  }

  getTypeStyles(type) {
    const styles = {
      success: {
        bg: 'bg-green-100 dark:bg-green-800',
        text: 'text-green-500 dark:text-green-200',
        icon: 'text-green-500 bg-green-100 dark:bg-green-800 dark:text-green-200'
      },
      error: {
        bg: 'bg-red-100 dark:bg-red-800',
        text: 'text-red-500 dark:text-red-200',
        icon: 'text-red-500 bg-red-100 dark:bg-red-800 dark:text-red-200'
      },
      warning: {
        bg: 'bg-yellow-100 dark:bg-yellow-800',
        text: 'text-yellow-500 dark:text-yellow-200',
        icon: 'text-yellow-500 bg-yellow-100 dark:bg-yellow-800 dark:text-yellow-200'
      },
      info: {
        bg: 'bg-blue-100 dark:bg-blue-800',
        text: 'text-blue-500 dark:text-blue-200',
        icon: 'text-blue-500 bg-blue-100 dark:bg-blue-800 dark:text-blue-200'
      }
    };
    return styles[type] || styles.info;
  }

}


// Helper functions for common toast types
const toast = new ToastNotification();

const gToast = {
  error: function (content) {
    return toast.init(content, 'error');
  },

  success: function (content) {
    return toast.init(content, 'success');
  },

  warning: function (content) {
    return toast.init(content, 'warning');
  },

  info: function (content) {
    return toast.init(content, 'info');
  }
};

/* 
  message: Notification text
  type: 'success', 'error', 'warning'
  position: 'top-right', 'top-left', 'bottom-right', 'bottom-left'
  animation: 'shakeIn', 'slideIn', 'swoosh', 'flash', 'bounce'
  duration: Time before auto-closing
  html: Set true to render HTML content
*/
const log = console.log.bind(console);
log("%cSTOP!", "color: red; font-size: x-large");
log("%cThis is a browser feature intended for developers. If someone told you to copy-paste something here to enable estate wake feature or 'hack' someone's account, it is a scam and will give them access to your estate wake account. ðŸ˜‰", "font-size: large");

